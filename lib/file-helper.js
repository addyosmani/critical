'use strict';

const os = require('os');
const url = require('url');
const path = require('path');
const fs = require('fs-extra');
const {chain, first, map} = require('lodash');
const Bluebird = require('bluebird');
const got = require('got');
const debug = require('debug')('critical:file');
const mime = require('mime-types');
const slash = require('slash');
const oust = require('oust');
const chalk = require('chalk');
const tempy = require('tempy');
// Use patched vinyl to allow remote paths
const File = require('./vinyl-remote');
const gc = require('./gc');

/**
 * Fixup slashes in file paths for windows
 * @param {string} str path
 * @returns {string}
 */
function normalizePath(str) {
    return process.platform === 'win32' ? slash(str) : str;
}

/**
 * Helper function to rewrite the file paths relative to the stylesheet
 * to be relative to the html file
 * @param {File} html
 * @param opts
 * @returns {function}
 */
function replaceAssetPaths(html, opts) {
    // Set dest path with fallback to html path
    const destPath = opts.destFolder || (opts.dest && path.dirname(opts.dest)) || path.dirname(html.path);
    const destPathResolved = path.resolve(destPath);
    const baseResolved = path.resolve(opts.base);

    /**
     * The resulting function should get passed an vinyl object with the css file
     */
    return stylesheet => {
        // Normalize relative paths
        const css = stylesheet.contents.toString().replace(/url\(['"]?([^'"\\)]+)['"]?\)/g, (match, assetPath) => {
            // Skip absolute paths, urls and data-uris
            if (assetPath.startsWith('data:') || /(?:^\/)|(?::\/\/)/.test(assetPath)) {
                return match;
            }

            // Create asset path relative to opts.base
            const stylesheetPath = path.dirname(stylesheet.path);
            const assetRelative = path.relative(baseResolved, path.resolve(path.join(stylesheetPath, assetPath)));

            // Compute path prefix default relative to html
            const pathPrefixDefault = path.relative(destPathResolved, baseResolved);

            const pathPrefix = (typeof opts.pathPrefix === 'undefined') ? pathPrefixDefault : opts.pathPrefix;

            return normalizePath(match.replace(assetPath, path.join(pathPrefix, assetRelative)));
        });

        stylesheet.contents = Buffer.from(css);
        return stylesheet;
    };
}

/**
 * Get html path for penthouse
 * Needs to be an absolute file:// url for local files to work on windows
 * @param {object} opts Options passed to critical
 * @param {File} file Vinyl file object of html file
 * @returns {string}
 */
function getPenthouseUrl(opts, file) {
    if (opts.src && isExternal(opts.src)) {
        debug('Fetching remote html:', opts.src);
        return opts.src;
    }

    let filepath = path.resolve(file.path);
    if (!fs.existsSync(filepath)) {
        filepath = path.resolve(file.history[0]);
    }

    debug('Fetching local html:', `file://${filepath}`);
    return `file://${filepath}`;
}

/**
 * Check wether a resource is external or not
 * @param {string} href
 * @returns {boolean}
 */
function isExternal(href) {
    return /(^\/\/)|(:\/\/)/.test(href);
}

/**
 * Generate temp file from request response object
 * @param {Response} resp response
 * @returns {Promise}
 */
function temp(resp) {
    const contentType = resp.headers['content-type'];
    return Promise.resolve()
        .then(() => {
            const filepath = tempy.file({extension: mime.extension(contentType)});
            gc.addFile(filepath);
            return fs.outputFile(filepath, resp.body).then(() => {
                return filepath;
            });
        });
}

/**
 * Token generated by concatenating username and password with `:` character within a base64 encoded string.
 * @param  {String} user User identifier.
 * @param  {String} pass Password.
 * @returns {String} Base64 encoded authentication token.
 */
const token = (user, pass) => Buffer.from([user, pass].join(':')).toString('base64');

/**
 * Get external resource
 * @param {string} uri
 * @param {boolean} secure
 * @param {object} opts Options passed to critical
 * @returns {Promise}
 */
function requestAsync(uri, secure = true, opts = {}) {
    const {user, pass, userAgent} = opts;
    let resourceUrl = uri;
    // Consider protocol-relative urls
    if (/^\/\//.test(uri)) {
        // eslint-disable-next-line node/no-deprecated-api
        resourceUrl = url.resolve(`http${secure ? 's' : ''}://te.st`, uri);
    }

    debug(`Fetching resource: ${resourceUrl}`);
    const options = {rejectUnauthorized: false, headers: {}};
    if (user && pass) {
        options.headers.Authorization = `Basic ${token(user, pass)}`;
    }

    if (userAgent) {
        options.headers['User-Agent'] = userAgent;
    }

    return got(resourceUrl, options).catch(error => {
        if (secure) {
            debug(`${error.message} - trying again over http`);
            return requestAsync(uri, false, opts);
        }

        debug(`${resourceUrl} failed: ${error.message}`);
        return Promise.resolve(error); // eslint-disable-line promise/no-return-wrap
    });
}

/**
 * Get default base path based on options
 * @param {object} opts Options passed to critical
 * @returns {string}
 */
function guessBasePath(opts) {
    if (opts.src && !isExternal(opts.src) && !isVinyl(opts.src)) {
        return path.dirname(opts.src);
    }

    if (opts.src && isVinyl(opts.src)) {
        return opts.src.dirname;
    }

    return process.cwd();
}

/**
 * Wrapper for File.isVinyl to detect vinyl objects generated by gulp (vinyl < v0.5.6)
 * @param {*} file
 * @returns {string}
 */
function isVinyl(file) {
    return File.isVinyl(file) ||
        file instanceof File ||
        (file && /function File\(/.test(file.constructor.toString()) && file.contents && file.path);
}

/**
 * Returns a promise to a local file
 * @param {string} filePath
 * @param {object} opts Options passed to critical
 * @returns {Promise}
 */
function assertLocal(filePath, opts = {}) {
    if (!isExternal(filePath)) {
        return new Bluebird(resolve => {
            resolve(filePath);
        });
    }

    return requestAsync(filePath, true, opts)
        .then(response => temp(response));
}

/**
 * Resolve path to file
 * @param {File} htmlfile Vinyl file object of html file
 * @param {object} opts Options passed to critical
 * @returns {function}
 */
function resourcePath(htmlfile, opts) {
    return filepath => {
        if (isExternal(filepath)) {
            debug('resourcePath - remote', filepath);
            return filepath;
        }

        if (isExternal(htmlfile.history[0])) {
            debug('resourcePath - remote', htmlfile.history[0]);
            // eslint-disable-next-line node/no-deprecated-api
            return url.resolve(htmlfile.history[0], filepath);
        }

        if (/(?:^\/)/.test(filepath)) {
            return path.join(opts.base, filepath.split('?')[0]);
        }

        const folder = path.relative(opts.base, path.dirname(htmlfile.path));
        if (folder) {
            debug('resourcePath - folder', folder);
        }

        return path.join(path.dirname(htmlfile.path), filepath.split('?')[0]);
    };
}

/**
 * Compute a source path which fits to the directory structure
 * so that relative links could be resolved
 * @param {object} opts Options passed to critical
 * @returns {string}
 */
function generateSourcePath(opts) {
    const {html} = opts;

    if (typeof opts.src !== 'undefined') {
        return path.dirname(opts.src);
    }

    if (typeof opts.folder !== 'undefined') {
        const folder = path.isAbsolute(opts.folder) ? opts.folder : path.join(opts.base, opts.folder);
        opts.pathPrefix = path.relative(opts.folder, opts.base);
        return folder;
    }

    if (!opts.pathPrefix) {
        const links = oust(html, 'stylesheets');

        debug('generateSourcePath - links', links);
        // We can only determine a valid path by checking relative links
        const relative = chain(links).omitBy(link => {
            return link.startsWith('data:') || /(?:^\/)|(?::\/\/)/.test(link);
        }).toArray().value();

        debug('generateSourcePath - relative', relative);

        if (relative.length === 0) {
            process.stderr.write([
                chalk.red('Warning:'),
                'Missing html source path. Consider \'folder\' option.',
                'https://goo.gl/PwvFVb',
                os.EOL
            ].join(' '));

            opts.pathPrefix = '/';
            return opts.base;
        }

        const dots = map(relative, link => {
            const match = /^(\.\.\/)+/.exec(link);
            return first(match);
        });

        opts.pathPrefix = chain(dots).sortBy('length').last().value() || '';
        debug('generateSourcePath', opts.pathPrefix.replace(/\.\./g, '~'));
    }

    return path.join(opts.base, opts.pathPrefix.replace(/\.\./g, '~'));
}

/**
 * Get vinyl object based on options
 * could either be a html string or a local file.
 * If opts.src already is a vinyl object it gets returnd without modifications
 * @param {object} opts Options passed to critical
 * @returns {promise} resolves to vinyl object
 */
function getVinylPromise(opts) {
    if (!(opts.src || opts.html) || !opts.base) {
        return Bluebird.reject(new Error('A valid source and base path are required.'));
    }

    if (isVinyl(opts.src)) {
        return new Bluebird(resolve => {
            resolve(opts.src);
        });
    }

    const file = new File({
        base: opts.base
    });

    if (opts.src && isExternal(opts.src)) {
        file.remotePath = opts.src;
    } else if (opts.src) {
        file.path = opts.src;
    }

    if (opts.html) {
        const folder = generateSourcePath(opts);
        debug('hacky source path folder', folder);

        // Html passed in directly -> create tmp file
        return Promise.resolve()
            .then(() => {
                const filepath = tempy.file({extension: 'html'});
                file.path = filepath;
                file.path = path.join(folder, path.basename(filepath));
                file.base = folder;
                file.contents = Buffer.from(opts.html);
                debug(file);
                gc.addFile(filepath);
                return fs.outputFile(filepath, file.contents).then(() => {
                    return file;
                });
            });
    }

    // Use src file provided, fetch content and return vinyl
    return assertLocal(opts.src, opts)
        .then(data => {
            // Src can either be absolute or relative to opts.base
            if (opts.src !== path.resolve(data) && !isExternal(opts.src)) {
                file.path = path.join(opts.base, opts.src);
            } else {
                file.path = path.relative(process.cwd(), data);
            }

            return fs.readFile(file.path).then(contents => {
                file.contents = contents;
                return file;
            });
        });
}

exports.normalizePath = normalizePath;
exports.isExternal = isExternal;
exports.isVinyl = isVinyl;
exports.replaceAssetPaths = replaceAssetPaths;
exports.getPenthouseUrl = getPenthouseUrl;
exports.guessBasePath = guessBasePath;
exports.resourcePath = resourcePath;
exports.assertLocal = assertLocal;
exports.getVinylPromise = getVinylPromise;
exports.token = token;
